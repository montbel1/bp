import { supabase } from "./supabase";

export interface AutoGeneratedEvent {
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  type: "ACCOUNTING" | "PRACTICE_MANAGEMENT";
  source: string;
  relatedId?: string;
}

export class CalendarService {
  /**
   * Generate calendar events from bookkeeping data
   */
  static async generateAccountingEvents(userEmail: string): Promise<AutoGeneratedEvent[]> {
    const events: AutoGeneratedEvent[] = [];

    // Generate events from recurring transactions
    const { data: recurringTransactions, error: recurringError } = await supabase
      .from('recurring_transactions')
      .select(`
        *,
        accounts!inner(*),
        categories(*)
      `)
      .eq('user_id', userEmail)
      .eq('is_active', true)
      .gte('next_due_date', new Date().toISOString())
      .lte('next_due_date', new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString());

    if (recurringError) {
      console.error('Error fetching recurring transactions:', recurringError);
      return events;
    }

    for (const transaction of recurringTransactions || []) {
      events.push({
        title: `Recurring Transaction: ${transaction.description}`,
        description: `Process recurring ${transaction.type.toLowerCase()} transaction for ${transaction.accounts?.name || 'Unknown Account'}`,
        startDate: new Date(transaction.next_due_date),
        endDate: new Date(new Date(transaction.next_due_date).getTime() + 60 * 60 * 1000), // 1 hour
        priority: transaction.amount > 1000 ? "HIGH" : "MEDIUM",
        type: "ACCOUNTING",
        source: "Recurring Transaction",
        relatedId: transaction.id,
      });
    }

    // Generate events from invoices
    const { data: overdueInvoices, error: invoiceError } = await supabase
      .from('invoices')
      .select(`
        *,
        customers(*)
      `)
      .eq('user_id', userEmail)
      .eq('status', 'SENT')
      .lt('due_date', new Date().toISOString());

    if (invoiceError) {
      console.error('Error fetching overdue invoices:', invoiceError);
      return events;
    }

    for (const invoice of overdueInvoices || []) {
      events.push({
        title: `Overdue Invoice: ${invoice.customers?.name || 'Unknown Customer'}`,
        description: `Follow up on overdue invoice #${invoice.number} for $${invoice.total}`,
        startDate: new Date(),
        endDate: new Date(Date.now() + 60 * 60 * 1000),
        priority: "URGENT",
        type: "ACCOUNTING",
        source: "Overdue Invoice",
        relatedId: invoice.id,
      });
    }

    // Generate events from bills
    const { data: upcomingBills, error: billError } = await supabase
      .from('bills')
      .select(`
        *,
        vendors(*)
      `)
      .eq('user_id', userEmail)
      .eq('status', 'RECEIVED')
      .gte('due_date', new Date().toISOString())
      .lte('due_date', new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString());

    if (billError) {
      console.error('Error fetching upcoming bills:', billError);
      return events;
    }

    for (const bill of upcomingBills || []) {
      events.push({
        title: `Pay Bill: ${bill.vendors?.name || 'Unknown Vendor'}`,
        description: `Pay bill #${bill.number} for $${bill.total} to ${bill.vendors?.name || 'Unknown Vendor'}`,
        startDate: new Date(bill.due_date),
        endDate: new Date(new Date(bill.due_date).getTime() + 60 * 60 * 1000),
        priority: bill.total > 1000 ? "HIGH" : "MEDIUM",
        type: "ACCOUNTING",
        source: "Upcoming Bill",
        relatedId: bill.id,
      });
    }

    return events;
  }

  /**
   * Generate calendar events from practice management data
   */
  static async generatePracticeManagementEvents(userEmail: string): Promise<AutoGeneratedEvent[]> {
    const events: AutoGeneratedEvent[] = [];

    // Generate events from jobs
    const { data: upcomingJobs, error: jobError } = await supabase
      .from('jobs')
      .select(`
        *,
        clients(*)
      `)
      .eq('user_id', userEmail)
      .in('status', ['PLANNING', 'IN_PROGRESS'])
      .gte('due_date', new Date().toISOString())
      .lte('due_date', new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString());

    if (jobError) {
      console.error('Error fetching upcoming jobs:', jobError);
      return events;
    }

    for (const job of upcomingJobs || []) {
      events.push({
        title: `Job Deadline: ${job.title}`,
        description: `Complete job for ${job.clients?.name || "Client"} - ${job.description || ''}`,
        startDate: new Date(job.due_date),
        endDate: new Date(new Date(job.due_date).getTime() + 4 * 60 * 60 * 1000), // 4 hours
        priority: job.priority === "URGENT" ? "URGENT" : job.priority === "HIGH" ? "HIGH" : "MEDIUM",
        type: "PRACTICE_MANAGEMENT",
        source: "Job Deadline",
        relatedId: job.id,
      });
    }

    // Generate events from tasks
    const { data: upcomingTasks, error: taskError } = await supabase
      .from('tasks')
      .select(`
        *,
        jobs!inner(
          *,
          clients(*)
        )
      `)
      .eq('user_id', userEmail)
      .in('status', ['TODO', 'IN_PROGRESS'])
      .gte('due_date', new Date().toISOString())
      .lte('due_date', new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString());

    if (taskError) {
      console.error('Error fetching upcoming tasks:', taskError);
      return events;
    }

    for (const task of upcomingTasks || []) {
      events.push({
        title: `Task: ${task.title}`,
        description: `${task.description || ''} - ${task.jobs?.clients?.name || "Client"}`,
        startDate: new Date(task.due_date),
        endDate: new Date(new Date(task.due_date).getTime() + 2 * 60 * 60 * 1000), // 2 hours
        priority: task.priority === "URGENT" ? "URGENT" : task.priority === "HIGH" ? "HIGH" : "MEDIUM",
        type: "PRACTICE_MANAGEMENT",
        source: "Task Deadline",
        relatedId: task.id,
      });
    }

    return events;
  }

  /**
   * Generate tax-related events based on common accounting deadlines
   */
  static async generateTaxEvents(userEmail: string): Promise<AutoGeneratedEvent[]> {
    const events: AutoGeneratedEvent[] = [];
    const currentYear = new Date().getFullYear();
    const nextYear = currentYear + 1;

    // Common tax deadlines
    const taxDeadlines = [
      {
        title: "1040 - Prepare Tax Return",
        description: "Begin preparing individual tax returns",
        date: new Date(currentYear, 2, 1), // March 1st
        priority: "HIGH" as const,
      },
      {
        title: "1040 - E-file Return",
        description: "E-file completed tax returns",
        date: new Date(currentYear, 3, 15), // April 15th
        priority: "URGENT" as const,
      },
      {
        title: "Quarterly Estimated Tax Payment - Q1",
        description: "Pay first quarter estimated taxes",
        date: new Date(currentYear, 3, 15), // April 15th
        priority: "HIGH" as const,
      },
      {
        title: "Quarterly Estimated Tax Payment - Q2",
        description: "Pay second quarter estimated taxes",
        date: new Date(currentYear, 5, 15), // June 15th
        priority: "HIGH" as const,
      },
      {
        title: "Quarterly Estimated Tax Payment - Q3",
        description: "Pay third quarter estimated taxes",
        date: new Date(currentYear, 8, 15), // September 15th
        priority: "HIGH" as const,
      },
      {
        title: "Quarterly Estimated Tax Payment - Q4",
        description: "Pay fourth quarter estimated taxes",
        date: new Date(currentYear, 11, 15), // December 15th
        priority: "HIGH" as const,
      },
    ];

    for (const deadline of taxDeadlines) {
      if (deadline.date >= new Date()) {
        events.push({
          title: deadline.title,
          description: deadline.description,
          startDate: deadline.date,
          endDate: new Date(deadline.date.getTime() + 4 * 60 * 60 * 1000), // 4 hours
          priority: deadline.priority,
          type: "ACCOUNTING",
          source: "Tax Deadline",
        });
      }
    }

    return events;
  }

  /**
   * Create calendar events from auto-generated events
   */
  static async createEventsFromAutoGenerated(
    userEmail: string,
    events: AutoGeneratedEvent[]
  ): Promise<void> {
    for (const event of events) {
      // Check if event already exists
      const { data: existingEvent, error: findError } = await supabase
        .from('calendar_events')
        .select('*')
        .eq('user_id', userEmail)
        .eq('title', event.title)
        .eq('start', event.startDate.toISOString())
        .single();

      if (findError && findError.code !== 'PGRST116') { // PGRST116 is "not found"
        console.error('Error checking for existing event:', findError);
        continue;
      }

      if (!existingEvent) {
        const { error: insertError } = await supabase
          .from('calendar_events')
          .insert({
            title: event.title,
            description: event.description,
            start: event.startDate.toISOString(),
            end: event.endDate.toISOString(),
            priority: event.priority,
            status: "SCHEDULED",
            user_id: userEmail,
            type: event.type,
            source: event.source,
            is_auto_generated: true,
          });

        if (insertError) {
          console.error('Error creating calendar event:', insertError);
        }
      }
    }
  }

  /**
   * Auto-generate all calendar events
   */
  static async autoGenerateAllEvents(userEmail: string): Promise<void> {
    const accountingEvents = await this.generateAccountingEvents(userEmail);
    const practiceManagementEvents = await this.generatePracticeManagementEvents(userEmail);
    const taxEvents = await this.generateTaxEvents(userEmail);

    const allEvents = [...accountingEvents, ...practiceManagementEvents, ...taxEvents];
    await this.createEventsFromAutoGenerated(userEmail, allEvents);
  }
} 
